<!doctype html><html lang=en-gb><head><meta charset=utf-8><meta name=viewport content="width=device-width"><script type=application/javascript src=https://stephenc.github.io/js/theme-mode.js></script><link rel=stylesheet href=https://stephenc.github.io/css/frameworks.min.css><link rel=stylesheet href=https://stephenc.github.io/css/github.min.css><link rel=stylesheet href=https://stephenc.github.io/css/github-style.css><link rel=stylesheet href=https://stephenc.github.io/css/light.css><link rel=stylesheet href=https://stephenc.github.io/css/dark.css><link rel=stylesheet href=https://stephenc.github.io/css/syntax.css><title>Writing a Hudson plug-in (Part 5 – Reporting) - Stephen's technical blog</title><link rel=icon type=image/x-icon href=https://stephenc.github.io/images/favicon.ico><meta name=theme-color content="#1e2327"><meta name=description content='Until now we have been generating classes that collect the results we want to display. We have not hooked into Hudson&rsquo;s methods of displaying reports. There are essentially four places that we could want to generate reports:In each individual build (we&rsquo;ll call this a Single Build Report),In the project (we&rsquo;ll call this a Single Project Report),In the summary of all the Maven 2 module builds associated with a multi-module Maven 2 build (we&rsquo;ll call this an Aggregate Build Report), and finallyIn the Maven 2 project itself (we&rsquo;ll call this an Aggregate Project Report).To make matters more confusing, each of these reports usually to implement different classes and need to implement different interfaces:Project Reports usually inherit from ActionableBuild Reports usually inherit from HealthReportingActionSingle Build Reports in Maven 2 projects need to implement AggregatableActionWhat we need is to put some common framework around these reports to ensure that we are not repeating ourselves all the time. In general, each of these four reports will be doing mostly the same things.The Build Reports will be displaying the results for a specific buildThe Project Reports will be displaying the results for the latest build (and possibly a trend chart if that makes sense)The Aggregate Reports will be displaying the aggregate of all the Single ReportsSound&rsquo;s like a job for multiple inheritance! Fortune would have it that Java does not support multiple inheritance, so we will have to use some form of composition to get the same effect, and generics can help reduce the repetition too. But enough! On to the solution.AbstractBuildActionWe&rsquo;ll start with a parent class for all our Build Reports. We&rsquo;ll make this class generic, parameterised by the Build class that it operates on, so that we can use the same core code for all the Build Reports:package hudson.plugins.helpers;import hudson.model.AbstractBuild;import hudson.model.HealthReportingAction;public abstract class AbstractBuildAction<BUILD extends AbstractBuild> implements HealthReportingAction { private BUILD build = null; protected AbstractBuildAction() { } public synchronized BUILD getBuild() { return build; } public synchronized void setBuild(BUILD build) { if (this.build == null && this.build != build) { this.build = build; } }}We store a reference to the build in a local variable and provide a getter for the build. Ideally we would like to the build variable to be final and initialize it in the constructor. However, Hudson&rsquo;s remoting interface will get in the way of this for any actions created on the slave. The solution is to use a setter to set the build. Additionally, we have some logic that makes this setter write-once. This is just a safety net to stop us from accidentally confusing Hudson. Strictly speaking, if you are careful the setter can be justa a simple setter and not write once.[Correction] We also need to modify BuildProxy so that it calls our setter for us for actions added from slave side executions:package hudson.plugsin.helpers;&mldr;public final class BuildProxy implements Serializable { &mldr; private final List<AbstractBuildAction<AbstractBuild&#187; actions = new ArrayList<AbstractBuildAction&#187;(); &mldr; public void updateBuild(AbstractBuild<,?> build) { for (AbstractBuildAction<AbstractBuild> action: actions) { if (!build.getActions().contains(action)) { action.setBuild(build); build.getActions().add(action); } } if (result != null && result.isWorseThan(build.getResult())) { build.setResult(result); } } &mldr; public List<AbstractBuildAction<AbstractBuild&#187; getActions() { return actions; } &mldr;}[/Correction]In addition to these simple getters and setters, we want to provide a framework for displaying the report detail. Each different type of report has different ways of fitting into the Hudson UI. We are going to attempt to standardise these by using wrapper .jelly files to call a standard set which implementing classes can override. Jelly files are stored as resources in the hudson plugin, so with the Maven2 project structure for a Hudson plugin, the java source is /src/main/java/hudson/plugins/helpers/AbstractBuildAction.java and the jelly files for this java class are in /src/main/resources/hudson/plugins/helpers/AbstractBuildAction/. The basic things that all build reports want to do are as follows:A main report detail page (e.g. package level summary of the number of lines of code)A graph of some sort, with the option to enlarge it. (e.g. trend graph of the number of lines of code)A simple summary of the report for the main page (i.e. &ldquo;17,345 lines of code (+1,534)")We will implement this functionality with some properties of the AbstractBuildAction, and some default .jelly files. First the additional properties:&mldr;public abstract class AbstractBuildAction<BUILD extends AbstractBuild> implements HealthReportingAction { &mldr; public boolean isFloatingBoxActive() { return false; } public boolean isGraphActive() { return false; } public String getGraphName() { return getDisplayName(); } public String getSummary() { return &ldquo;&rdquo;; }}These four properties will be used to control how the action appears. isFloatingBoxActive allows us to enable the floating box on the build summary page. isGraphActive allows us to activate the graph inside the floating box. getGraphName should return the title that will be displayed above the graph. And finally, getSummary will control the summary text to display beside the build report icon on the build summary page.Next we have some empty default place-holder jelly files. These will be the jelly files that we can override in our actual reports:reportDetail.jelly<j:jelly xmlns:j=&ldquo;jelly:core&rdquo; xmlns:st=&ldquo;jelly:stapler&rdquo; xmlns:d=&ldquo;jelly:define&rdquo; xmlns:l="/lib/layout&rdquo; xmlns:t="/lib/hudson" xmlns:f="/lib/form"></j:jelly>normalGraph.jelly<j:jelly xmlns:j=&ldquo;jelly:core&rdquo; xmlns:st=&ldquo;jelly:stapler&rdquo; xmlns:d=&ldquo;jelly:define&rdquo; xmlns:l="/lib/layout" xmlns:t="/lib/hudson" xmlns:f="/lib/form"></j:jelly>largeGraph.jelly<j:jelly xmlns:j=&ldquo;jelly:core&rdquo; xmlns:st=&ldquo;jelly:stapler&rdquo; xmlns:d=&ldquo;jelly:define&rdquo; xmlns:l="/lib/layout" xmlns:t="/lib/hudson" xmlns:f="/lib/form"></j:jelly>The reportDetail.jelly page will be used for the main report detail page, the normalGraph.jelly page will be used for the floating trend graph, while the largeGraph.jelly page will be used for the enlarged graph. To hook these pages into the Hudson framework, we need the following jelly pages:index.jelly<j:jelly xmlns:j=&ldquo;jelly:core&rdquo; xmlns:st=&ldquo;jelly:stapler&rdquo; xmlns:d=&ldquo;jelly:define&rdquo; xmlns:l="/lib/layout" xmlns:t="/lib/hudson" xmlns:f="/lib/form"> <l:layout xmlns:plugin="/hudson/plugins/javancss/tags" css="/plugin/javancss/css/style.css"> <st:include it="${it.build}" page=&ldquo;sidepanel.jelly&rdquo;/> <l:main-panel> ${it.displayName} <j:if test="${it.graphActive}"> ${it.graphName} <st:include page=&ldquo;normalGraph.jelly&rdquo;/> </j:if> <st:include page=&ldquo;reportDetail.jelly&rdquo;/> </l:main-panel> </l:layout></j:jelly>This page will also include the trend graph if it is activefloatingBox.jelly<j:jelly xmlns:j=&ldquo;jelly:core&rdquo; xmlns:st=&ldquo;jelly:stapler&rdquo; xmlns:d=&ldquo;jelly:define&rdquo; xmlns:l="/lib/layout" xmlns:t="/lib/hudson" xmlns:f="/lib/form"> <j:if test="${it.graphActive}"> ${from.graphName} <st:include page=&ldquo;normalGraph.jelly&rdquo;/> enlarge </j:if></j:jelly>summary.jelly<j:jelly xmlns:j=&ldquo;jelly:core&rdquo; xmlns:st=&ldquo;jelly:stapler&rdquo; xmlns:d=&ldquo;jelly:define&rdquo; xmlns:l="/lib/layout" xmlns:t="/lib/hudson" xmlns:f="/lib/form" xmlns:i=&ldquo;jelly:fmt&rdquo;> <t:summary icon="${it.iconFileName}"> ${it.displayName} ${it.summary} </t:summary> <j:if test="${it.floatingBoxVisible}}"> <st:include page=&ldquo;floatingBox.jelly&rdquo;/> </j:if></j:jelly>Note that the build main page does not support floating boxes, so we have to hack it in via the summary.jelly pageenlargedGraph.jelly<j:jelly xmlns:j=&ldquo;jelly:core&rdquo; xmlns:st=&ldquo;jelly:stapler&rdquo; xmlns:d=&ldquo;jelly:define&rdquo; xmlns:l="/lib/layout" xmlns:t="/lib/hudson" xmlns:f="/lib/form"> <l:layout xmlns:plugin="/hudson/plugins/javancss/tags" css="/plugin/javancss/css/style.css"> <st:include it="${it.build}" page=&ldquo;sidepanel.jelly&rdquo;/> <l:main-panel> <j:if test="${it.graphActive}"> ${it.graphName} <st:include page=&ldquo;largeGraph.jelly&rdquo;/> </j:if> </l:main-panel> </l:layout></j:jelly>AbstractProjectActionThis is similar to AbstractBuildAction, however, we don&rsquo;t have to deal with the write-once setter problem.package hudson.plugins.helpers;import hudson.model.AbstractProject;import hudson.model.Actionable;abstract public class AbstractProjectAction<PROJECT extends AbstractProject> extends Actionable { private final PROJECT project; protected AbstractProjectAction(PROJECT project) { this.project = project; } public PROJECT getProject() { return project; } public boolean isFloatingBoxActive() { return true; } public boolean isGraphActive() { return false; } public String getGraphName() { return getDisplayName(); }}Again we have a set of jelly files, we&rsquo;ll repeat the same placeholders:reportDetail.jelly<j:jelly xmlns:j=&ldquo;jelly:core&rdquo; xmlns:st=&ldquo;jelly:stapler&rdquo; xmlns:d=&ldquo;jelly:define&rdquo; xmlns:l="/lib/layout" xmlns:t="/lib/hudson" xmlns:f="/lib/form"></j:jelly>normalGraph.jelly<j:jelly xmlns:j=&ldquo;jelly:core&rdquo; xmlns:st=&ldquo;jelly:stapler&rdquo; xmlns:d=&ldquo;jelly:define&rdquo; xmlns:l="/lib/layout" xmlns:t="/lib/hudson" xmlns:f="/lib/form"></j:jelly>largeGraph.jelly<j:jelly xmlns:j=&ldquo;jelly:core&rdquo; xmlns:st=&ldquo;jelly:stapler&rdquo; xmlns:d=&ldquo;jelly:define&rdquo; xmlns:l="/lib/layout" xmlns:t="/lib/hudson" xmlns:f="/lib/form"></j:jelly>The other link in pages are similar, only changing from a reference for ${it.build} to ${it.project}index.jelly<j:jelly xmlns:j=&ldquo;jelly:core&rdquo; xmlns:st=&ldquo;jelly:stapler&rdquo; xmlns:d=&ldquo;jelly:define&rdquo; xmlns:l="/lib/layout" xmlns:t="/lib/hudson" xmlns:f="/lib/form"> <l:layout xmlns:plugin="/hudson/plugins/javancss/tags" css="/plugin/javancss/css/style.css"> <st:include it="${it.project}" page=&ldquo;sidepanel.jelly&rdquo;/> <l:main-panel> ${it.displayName} <j:if test="${it.graphActive}"> ${it.graphName} <st:include page=&ldquo;normalGraph.jelly&rdquo;/> </j:if> <st:include page=&ldquo;reportDetail.jelly&rdquo;/> </l:main-panel> </l:layout></j:jelly>floatingBox.jelly<j:jelly xmlns:j=&ldquo;jelly:core&rdquo; xmlns:st=&ldquo;jelly:stapler&rdquo; xmlns:d=&ldquo;jelly:define&rdquo; xmlns:l="/lib/layout" xmlns:t="/lib/hudson" xmlns:f="/lib/form" xmlns:i=&ldquo;jelly:fmt&rdquo; xmlns:local=&ldquo;local&rdquo;> <j:if test="${it.graphActive}"> ${from.graphName} <st:include page=&ldquo;normalGraph.jelly&rdquo;/> enlarge </j:if></j:jelly>The project page automatically includes the floating box, so we don;t require the summary hackenlargedGraph.jelly<j:jelly xmlns:j=&ldquo;jelly:core&rdquo; xmlns:st=&ldquo;jelly:stapler&rdquo; xmlns:d=&ldquo;jelly:define&rdquo; xmlns:l="/lib/layout" xmlns:t="/lib/hudson" xmlns:f="/lib/form"> <l:layout xmlns:plugin="/hudson/plugins/javancss/tags" css="/plugin/javancss/css/style.css"> <st:include it="${it.project}" page=&ldquo;sidepanel.jelly&rdquo;/> <l:main-panel> <j:if test="${it.graphActive}"> ${it.graphName} <st:include page=&ldquo;largeGraph.jelly&rdquo;/> </j:if> </l:main-panel> </l:layout></j:jelly>SummaryThat&rsquo;s it for part 5, next time we will implement the javancss parser and get the results for a build. Part 7 will finish off the plugin with the reports based on these two base classes.
'><meta name=keywords content='blog'><meta name=robots content="noodp"><link rel=canonical href=https://stephenc.github.io/post/2008-02-01-writing-a-hudson-plug-in-part-5-reporting/><meta name=twitter:card content="summary"><meta name=twitter:title content="Writing a Hudson plug-in (Part 5 – Reporting) - Stephen's technical blog"><meta name=twitter:description content='Until now we have been generating classes that collect the results we want to display. We have not hooked into Hudson&rsquo;s methods of displaying reports. There are essentially four places that we could want to generate reports:In each individual build (we&rsquo;ll call this a Single Build Report),In the project (we&rsquo;ll call this a Single Project Report),In the summary of all the Maven 2 module builds associated with a multi-module Maven 2 build (we&rsquo;ll call this an Aggregate Build Report), and finallyIn the Maven 2 project itself (we&rsquo;ll call this an Aggregate Project Report).To make matters more confusing, each of these reports usually to implement different classes and need to implement different interfaces:Project Reports usually inherit from ActionableBuild Reports usually inherit from HealthReportingActionSingle Build Reports in Maven 2 projects need to implement AggregatableActionWhat we need is to put some common framework around these reports to ensure that we are not repeating ourselves all the time. In general, each of these four reports will be doing mostly the same things.The Build Reports will be displaying the results for a specific buildThe Project Reports will be displaying the results for the latest build (and possibly a trend chart if that makes sense)The Aggregate Reports will be displaying the aggregate of all the Single ReportsSound&rsquo;s like a job for multiple inheritance! Fortune would have it that Java does not support multiple inheritance, so we will have to use some form of composition to get the same effect, and generics can help reduce the repetition too. But enough! On to the solution.AbstractBuildActionWe&rsquo;ll start with a parent class for all our Build Reports. We&rsquo;ll make this class generic, parameterised by the Build class that it operates on, so that we can use the same core code for all the Build Reports:package hudson.plugins.helpers;import hudson.model.AbstractBuild;import hudson.model.HealthReportingAction;public abstract class AbstractBuildAction<BUILD extends AbstractBuild> implements HealthReportingAction { private BUILD build = null; protected AbstractBuildAction() { } public synchronized BUILD getBuild() { return build; } public synchronized void setBuild(BUILD build) { if (this.build == null && this.build != build) { this.build = build; } }}We store a reference to the build in a local variable and provide a getter for the build. Ideally we would like to the build variable to be final and initialize it in the constructor. However, Hudson&rsquo;s remoting interface will get in the way of this for any actions created on the slave. The solution is to use a setter to set the build. Additionally, we have some logic that makes this setter write-once. This is just a safety net to stop us from accidentally confusing Hudson. Strictly speaking, if you are careful the setter can be justa a simple setter and not write once.[Correction] We also need to modify BuildProxy so that it calls our setter for us for actions added from slave side executions:package hudson.plugsin.helpers;&mldr;public final class BuildProxy implements Serializable { &mldr; private final List<AbstractBuildAction<AbstractBuild&#187; actions = new ArrayList<AbstractBuildAction&#187;(); &mldr; public void updateBuild(AbstractBuild<,?> build) { for (AbstractBuildAction<AbstractBuild> action: actions) { if (!build.getActions().contains(action)) { action.setBuild(build); build.getActions().add(action); } } if (result != null && result.isWorseThan(build.getResult())) { build.setResult(result); } } &mldr; public List<AbstractBuildAction<AbstractBuild&#187; getActions() { return actions; } &mldr;}[/Correction]In addition to these simple getters and setters, we want to provide a framework for displaying the report detail. Each different type of report has different ways of fitting into the Hudson UI. We are going to attempt to standardise these by using wrapper .jelly files to call a standard set which implementing classes can override. Jelly files are stored as resources in the hudson plugin, so with the Maven2 project structure for a Hudson plugin, the java source is /src/main/java/hudson/plugins/helpers/AbstractBuildAction.java and the jelly files for this java class are in /src/main/resources/hudson/plugins/helpers/AbstractBuildAction/. The basic things that all build reports want to do are as follows:A main report detail page (e.g. package level summary of the number of lines of code)A graph of some sort, with the option to enlarge it. (e.g. trend graph of the number of lines of code)A simple summary of the report for the main page (i.e. &ldquo;17,345 lines of code (+1,534)")We will implement this functionality with some properties of the AbstractBuildAction, and some default .jelly files. First the additional properties:&mldr;public abstract class AbstractBuildAction<BUILD extends AbstractBuild> implements HealthReportingAction { &mldr; public boolean isFloatingBoxActive() { return false; } public boolean isGraphActive() { return false; } public String getGraphName() { return getDisplayName(); } public String getSummary() { return &ldquo;&rdquo;; }}These four properties will be used to control how the action appears. isFloatingBoxActive allows us to enable the floating box on the build summary page. isGraphActive allows us to activate the graph inside the floating box. getGraphName should return the title that will be displayed above the graph. And finally, getSummary will control the summary text to display beside the build report icon on the build summary page.Next we have some empty default place-holder jelly files. These will be the jelly files that we can override in our actual reports:reportDetail.jelly<j:jelly xmlns:j=&ldquo;jelly:core&rdquo; xmlns:st=&ldquo;jelly:stapler&rdquo; xmlns:d=&ldquo;jelly:define&rdquo; xmlns:l="/lib/layout&rdquo; xmlns:t="/lib/hudson" xmlns:f="/lib/form"></j:jelly>normalGraph.jelly<j:jelly xmlns:j=&ldquo;jelly:core&rdquo; xmlns:st=&ldquo;jelly:stapler&rdquo; xmlns:d=&ldquo;jelly:define&rdquo; xmlns:l="/lib/layout" xmlns:t="/lib/hudson" xmlns:f="/lib/form"></j:jelly>largeGraph.jelly<j:jelly xmlns:j=&ldquo;jelly:core&rdquo; xmlns:st=&ldquo;jelly:stapler&rdquo; xmlns:d=&ldquo;jelly:define&rdquo; xmlns:l="/lib/layout" xmlns:t="/lib/hudson" xmlns:f="/lib/form"></j:jelly>The reportDetail.jelly page will be used for the main report detail page, the normalGraph.jelly page will be used for the floating trend graph, while the largeGraph.jelly page will be used for the enlarged graph. To hook these pages into the Hudson framework, we need the following jelly pages:index.jelly<j:jelly xmlns:j=&ldquo;jelly:core&rdquo; xmlns:st=&ldquo;jelly:stapler&rdquo; xmlns:d=&ldquo;jelly:define&rdquo; xmlns:l="/lib/layout" xmlns:t="/lib/hudson" xmlns:f="/lib/form"> <l:layout xmlns:plugin="/hudson/plugins/javancss/tags" css="/plugin/javancss/css/style.css"> <st:include it="${it.build}" page=&ldquo;sidepanel.jelly&rdquo;/> <l:main-panel> ${it.displayName} <j:if test="${it.graphActive}"> ${it.graphName} <st:include page=&ldquo;normalGraph.jelly&rdquo;/> </j:if> <st:include page=&ldquo;reportDetail.jelly&rdquo;/> </l:main-panel> </l:layout></j:jelly>This page will also include the trend graph if it is activefloatingBox.jelly<j:jelly xmlns:j=&ldquo;jelly:core&rdquo; xmlns:st=&ldquo;jelly:stapler&rdquo; xmlns:d=&ldquo;jelly:define&rdquo; xmlns:l="/lib/layout" xmlns:t="/lib/hudson" xmlns:f="/lib/form"> <j:if test="${it.graphActive}"> ${from.graphName} <st:include page=&ldquo;normalGraph.jelly&rdquo;/> enlarge </j:if></j:jelly>summary.jelly<j:jelly xmlns:j=&ldquo;jelly:core&rdquo; xmlns:st=&ldquo;jelly:stapler&rdquo; xmlns:d=&ldquo;jelly:define&rdquo; xmlns:l="/lib/layout" xmlns:t="/lib/hudson" xmlns:f="/lib/form" xmlns:i=&ldquo;jelly:fmt&rdquo;> <t:summary icon="${it.iconFileName}"> ${it.displayName} ${it.summary} </t:summary> <j:if test="${it.floatingBoxVisible}}"> <st:include page=&ldquo;floatingBox.jelly&rdquo;/> </j:if></j:jelly>Note that the build main page does not support floating boxes, so we have to hack it in via the summary.jelly pageenlargedGraph.jelly<j:jelly xmlns:j=&ldquo;jelly:core&rdquo; xmlns:st=&ldquo;jelly:stapler&rdquo; xmlns:d=&ldquo;jelly:define&rdquo; xmlns:l="/lib/layout" xmlns:t="/lib/hudson" xmlns:f="/lib/form"> <l:layout xmlns:plugin="/hudson/plugins/javancss/tags" css="/plugin/javancss/css/style.css"> <st:include it="${it.build}" page=&ldquo;sidepanel.jelly&rdquo;/> <l:main-panel> <j:if test="${it.graphActive}"> ${it.graphName} <st:include page=&ldquo;largeGraph.jelly&rdquo;/> </j:if> </l:main-panel> </l:layout></j:jelly>AbstractProjectActionThis is similar to AbstractBuildAction, however, we don&rsquo;t have to deal with the write-once setter problem.package hudson.plugins.helpers;import hudson.model.AbstractProject;import hudson.model.Actionable;abstract public class AbstractProjectAction<PROJECT extends AbstractProject> extends Actionable { private final PROJECT project; protected AbstractProjectAction(PROJECT project) { this.project = project; } public PROJECT getProject() { return project; } public boolean isFloatingBoxActive() { return true; } public boolean isGraphActive() { return false; } public String getGraphName() { return getDisplayName(); }}Again we have a set of jelly files, we&rsquo;ll repeat the same placeholders:reportDetail.jelly<j:jelly xmlns:j=&ldquo;jelly:core&rdquo; xmlns:st=&ldquo;jelly:stapler&rdquo; xmlns:d=&ldquo;jelly:define&rdquo; xmlns:l="/lib/layout" xmlns:t="/lib/hudson" xmlns:f="/lib/form"></j:jelly>normalGraph.jelly<j:jelly xmlns:j=&ldquo;jelly:core&rdquo; xmlns:st=&ldquo;jelly:stapler&rdquo; xmlns:d=&ldquo;jelly:define&rdquo; xmlns:l="/lib/layout" xmlns:t="/lib/hudson" xmlns:f="/lib/form"></j:jelly>largeGraph.jelly<j:jelly xmlns:j=&ldquo;jelly:core&rdquo; xmlns:st=&ldquo;jelly:stapler&rdquo; xmlns:d=&ldquo;jelly:define&rdquo; xmlns:l="/lib/layout" xmlns:t="/lib/hudson" xmlns:f="/lib/form"></j:jelly>The other link in pages are similar, only changing from a reference for ${it.build} to ${it.project}index.jelly<j:jelly xmlns:j=&ldquo;jelly:core&rdquo; xmlns:st=&ldquo;jelly:stapler&rdquo; xmlns:d=&ldquo;jelly:define&rdquo; xmlns:l="/lib/layout" xmlns:t="/lib/hudson" xmlns:f="/lib/form"> <l:layout xmlns:plugin="/hudson/plugins/javancss/tags" css="/plugin/javancss/css/style.css"> <st:include it="${it.project}" page=&ldquo;sidepanel.jelly&rdquo;/> <l:main-panel> ${it.displayName} <j:if test="${it.graphActive}"> ${it.graphName} <st:include page=&ldquo;normalGraph.jelly&rdquo;/> </j:if> <st:include page=&ldquo;reportDetail.jelly&rdquo;/> </l:main-panel> </l:layout></j:jelly>floatingBox.jelly<j:jelly xmlns:j=&ldquo;jelly:core&rdquo; xmlns:st=&ldquo;jelly:stapler&rdquo; xmlns:d=&ldquo;jelly:define&rdquo; xmlns:l="/lib/layout" xmlns:t="/lib/hudson" xmlns:f="/lib/form" xmlns:i=&ldquo;jelly:fmt&rdquo; xmlns:local=&ldquo;local&rdquo;> <j:if test="${it.graphActive}"> ${from.graphName} <st:include page=&ldquo;normalGraph.jelly&rdquo;/> enlarge </j:if></j:jelly>The project page automatically includes the floating box, so we don;t require the summary hackenlargedGraph.jelly<j:jelly xmlns:j=&ldquo;jelly:core&rdquo; xmlns:st=&ldquo;jelly:stapler&rdquo; xmlns:d=&ldquo;jelly:define&rdquo; xmlns:l="/lib/layout" xmlns:t="/lib/hudson" xmlns:f="/lib/form"> <l:layout xmlns:plugin="/hudson/plugins/javancss/tags" css="/plugin/javancss/css/style.css"> <st:include it="${it.project}" page=&ldquo;sidepanel.jelly&rdquo;/> <l:main-panel> <j:if test="${it.graphActive}"> ${it.graphName} <st:include page=&ldquo;largeGraph.jelly&rdquo;/> </j:if> </l:main-panel> </l:layout></j:jelly>SummaryThat&rsquo;s it for part 5, next time we will implement the javancss parser and get the results for a build. Part 7 will finish off the plugin with the reports based on these two base classes.
'><meta name=twitter:site content="https://stephenc.github.io/"><meta name=twitter:creator content><meta name=twitter:image content="https://stephenc.github.io/"><meta property="og:type" content="article"><meta property="og:title" content="Writing a Hudson plug-in (Part 5 – Reporting) - Stephen's technical blog"><meta property="og:description" content='Until now we have been generating classes that collect the results we want to display. We have not hooked into Hudson&rsquo;s methods of displaying reports. There are essentially four places that we could want to generate reports:In each individual build (we&rsquo;ll call this a Single Build Report),In the project (we&rsquo;ll call this a Single Project Report),In the summary of all the Maven 2 module builds associated with a multi-module Maven 2 build (we&rsquo;ll call this an Aggregate Build Report), and finallyIn the Maven 2 project itself (we&rsquo;ll call this an Aggregate Project Report).To make matters more confusing, each of these reports usually to implement different classes and need to implement different interfaces:Project Reports usually inherit from ActionableBuild Reports usually inherit from HealthReportingActionSingle Build Reports in Maven 2 projects need to implement AggregatableActionWhat we need is to put some common framework around these reports to ensure that we are not repeating ourselves all the time. In general, each of these four reports will be doing mostly the same things.The Build Reports will be displaying the results for a specific buildThe Project Reports will be displaying the results for the latest build (and possibly a trend chart if that makes sense)The Aggregate Reports will be displaying the aggregate of all the Single ReportsSound&rsquo;s like a job for multiple inheritance! Fortune would have it that Java does not support multiple inheritance, so we will have to use some form of composition to get the same effect, and generics can help reduce the repetition too. But enough! On to the solution.AbstractBuildActionWe&rsquo;ll start with a parent class for all our Build Reports. We&rsquo;ll make this class generic, parameterised by the Build class that it operates on, so that we can use the same core code for all the Build Reports:package hudson.plugins.helpers;import hudson.model.AbstractBuild;import hudson.model.HealthReportingAction;public abstract class AbstractBuildAction<BUILD extends AbstractBuild> implements HealthReportingAction { private BUILD build = null; protected AbstractBuildAction() { } public synchronized BUILD getBuild() { return build; } public synchronized void setBuild(BUILD build) { if (this.build == null && this.build != build) { this.build = build; } }}We store a reference to the build in a local variable and provide a getter for the build. Ideally we would like to the build variable to be final and initialize it in the constructor. However, Hudson&rsquo;s remoting interface will get in the way of this for any actions created on the slave. The solution is to use a setter to set the build. Additionally, we have some logic that makes this setter write-once. This is just a safety net to stop us from accidentally confusing Hudson. Strictly speaking, if you are careful the setter can be justa a simple setter and not write once.[Correction] We also need to modify BuildProxy so that it calls our setter for us for actions added from slave side executions:package hudson.plugsin.helpers;&mldr;public final class BuildProxy implements Serializable { &mldr; private final List<AbstractBuildAction<AbstractBuild&#187; actions = new ArrayList<AbstractBuildAction&#187;(); &mldr; public void updateBuild(AbstractBuild<,?> build) { for (AbstractBuildAction<AbstractBuild> action: actions) { if (!build.getActions().contains(action)) { action.setBuild(build); build.getActions().add(action); } } if (result != null && result.isWorseThan(build.getResult())) { build.setResult(result); } } &mldr; public List<AbstractBuildAction<AbstractBuild&#187; getActions() { return actions; } &mldr;}[/Correction]In addition to these simple getters and setters, we want to provide a framework for displaying the report detail. Each different type of report has different ways of fitting into the Hudson UI. We are going to attempt to standardise these by using wrapper .jelly files to call a standard set which implementing classes can override. Jelly files are stored as resources in the hudson plugin, so with the Maven2 project structure for a Hudson plugin, the java source is /src/main/java/hudson/plugins/helpers/AbstractBuildAction.java and the jelly files for this java class are in /src/main/resources/hudson/plugins/helpers/AbstractBuildAction/. The basic things that all build reports want to do are as follows:A main report detail page (e.g. package level summary of the number of lines of code)A graph of some sort, with the option to enlarge it. (e.g. trend graph of the number of lines of code)A simple summary of the report for the main page (i.e. &ldquo;17,345 lines of code (+1,534)")We will implement this functionality with some properties of the AbstractBuildAction, and some default .jelly files. First the additional properties:&mldr;public abstract class AbstractBuildAction<BUILD extends AbstractBuild> implements HealthReportingAction { &mldr; public boolean isFloatingBoxActive() { return false; } public boolean isGraphActive() { return false; } public String getGraphName() { return getDisplayName(); } public String getSummary() { return &ldquo;&rdquo;; }}These four properties will be used to control how the action appears. isFloatingBoxActive allows us to enable the floating box on the build summary page. isGraphActive allows us to activate the graph inside the floating box. getGraphName should return the title that will be displayed above the graph. And finally, getSummary will control the summary text to display beside the build report icon on the build summary page.Next we have some empty default place-holder jelly files. These will be the jelly files that we can override in our actual reports:reportDetail.jelly<j:jelly xmlns:j=&ldquo;jelly:core&rdquo; xmlns:st=&ldquo;jelly:stapler&rdquo; xmlns:d=&ldquo;jelly:define&rdquo; xmlns:l="/lib/layout&rdquo; xmlns:t="/lib/hudson" xmlns:f="/lib/form"></j:jelly>normalGraph.jelly<j:jelly xmlns:j=&ldquo;jelly:core&rdquo; xmlns:st=&ldquo;jelly:stapler&rdquo; xmlns:d=&ldquo;jelly:define&rdquo; xmlns:l="/lib/layout" xmlns:t="/lib/hudson" xmlns:f="/lib/form"></j:jelly>largeGraph.jelly<j:jelly xmlns:j=&ldquo;jelly:core&rdquo; xmlns:st=&ldquo;jelly:stapler&rdquo; xmlns:d=&ldquo;jelly:define&rdquo; xmlns:l="/lib/layout" xmlns:t="/lib/hudson" xmlns:f="/lib/form"></j:jelly>The reportDetail.jelly page will be used for the main report detail page, the normalGraph.jelly page will be used for the floating trend graph, while the largeGraph.jelly page will be used for the enlarged graph. To hook these pages into the Hudson framework, we need the following jelly pages:index.jelly<j:jelly xmlns:j=&ldquo;jelly:core&rdquo; xmlns:st=&ldquo;jelly:stapler&rdquo; xmlns:d=&ldquo;jelly:define&rdquo; xmlns:l="/lib/layout" xmlns:t="/lib/hudson" xmlns:f="/lib/form"> <l:layout xmlns:plugin="/hudson/plugins/javancss/tags" css="/plugin/javancss/css/style.css"> <st:include it="${it.build}" page=&ldquo;sidepanel.jelly&rdquo;/> <l:main-panel> ${it.displayName} <j:if test="${it.graphActive}"> ${it.graphName} <st:include page=&ldquo;normalGraph.jelly&rdquo;/> </j:if> <st:include page=&ldquo;reportDetail.jelly&rdquo;/> </l:main-panel> </l:layout></j:jelly>This page will also include the trend graph if it is activefloatingBox.jelly<j:jelly xmlns:j=&ldquo;jelly:core&rdquo; xmlns:st=&ldquo;jelly:stapler&rdquo; xmlns:d=&ldquo;jelly:define&rdquo; xmlns:l="/lib/layout" xmlns:t="/lib/hudson" xmlns:f="/lib/form"> <j:if test="${it.graphActive}"> ${from.graphName} <st:include page=&ldquo;normalGraph.jelly&rdquo;/> enlarge </j:if></j:jelly>summary.jelly<j:jelly xmlns:j=&ldquo;jelly:core&rdquo; xmlns:st=&ldquo;jelly:stapler&rdquo; xmlns:d=&ldquo;jelly:define&rdquo; xmlns:l="/lib/layout" xmlns:t="/lib/hudson" xmlns:f="/lib/form" xmlns:i=&ldquo;jelly:fmt&rdquo;> <t:summary icon="${it.iconFileName}"> ${it.displayName} ${it.summary} </t:summary> <j:if test="${it.floatingBoxVisible}}"> <st:include page=&ldquo;floatingBox.jelly&rdquo;/> </j:if></j:jelly>Note that the build main page does not support floating boxes, so we have to hack it in via the summary.jelly pageenlargedGraph.jelly<j:jelly xmlns:j=&ldquo;jelly:core&rdquo; xmlns:st=&ldquo;jelly:stapler&rdquo; xmlns:d=&ldquo;jelly:define&rdquo; xmlns:l="/lib/layout" xmlns:t="/lib/hudson" xmlns:f="/lib/form"> <l:layout xmlns:plugin="/hudson/plugins/javancss/tags" css="/plugin/javancss/css/style.css"> <st:include it="${it.build}" page=&ldquo;sidepanel.jelly&rdquo;/> <l:main-panel> <j:if test="${it.graphActive}"> ${it.graphName} <st:include page=&ldquo;largeGraph.jelly&rdquo;/> </j:if> </l:main-panel> </l:layout></j:jelly>AbstractProjectActionThis is similar to AbstractBuildAction, however, we don&rsquo;t have to deal with the write-once setter problem.package hudson.plugins.helpers;import hudson.model.AbstractProject;import hudson.model.Actionable;abstract public class AbstractProjectAction<PROJECT extends AbstractProject> extends Actionable { private final PROJECT project; protected AbstractProjectAction(PROJECT project) { this.project = project; } public PROJECT getProject() { return project; } public boolean isFloatingBoxActive() { return true; } public boolean isGraphActive() { return false; } public String getGraphName() { return getDisplayName(); }}Again we have a set of jelly files, we&rsquo;ll repeat the same placeholders:reportDetail.jelly<j:jelly xmlns:j=&ldquo;jelly:core&rdquo; xmlns:st=&ldquo;jelly:stapler&rdquo; xmlns:d=&ldquo;jelly:define&rdquo; xmlns:l="/lib/layout" xmlns:t="/lib/hudson" xmlns:f="/lib/form"></j:jelly>normalGraph.jelly<j:jelly xmlns:j=&ldquo;jelly:core&rdquo; xmlns:st=&ldquo;jelly:stapler&rdquo; xmlns:d=&ldquo;jelly:define&rdquo; xmlns:l="/lib/layout" xmlns:t="/lib/hudson" xmlns:f="/lib/form"></j:jelly>largeGraph.jelly<j:jelly xmlns:j=&ldquo;jelly:core&rdquo; xmlns:st=&ldquo;jelly:stapler&rdquo; xmlns:d=&ldquo;jelly:define&rdquo; xmlns:l="/lib/layout" xmlns:t="/lib/hudson" xmlns:f="/lib/form"></j:jelly>The other link in pages are similar, only changing from a reference for ${it.build} to ${it.project}index.jelly<j:jelly xmlns:j=&ldquo;jelly:core&rdquo; xmlns:st=&ldquo;jelly:stapler&rdquo; xmlns:d=&ldquo;jelly:define&rdquo; xmlns:l="/lib/layout" xmlns:t="/lib/hudson" xmlns:f="/lib/form"> <l:layout xmlns:plugin="/hudson/plugins/javancss/tags" css="/plugin/javancss/css/style.css"> <st:include it="${it.project}" page=&ldquo;sidepanel.jelly&rdquo;/> <l:main-panel> ${it.displayName} <j:if test="${it.graphActive}"> ${it.graphName} <st:include page=&ldquo;normalGraph.jelly&rdquo;/> </j:if> <st:include page=&ldquo;reportDetail.jelly&rdquo;/> </l:main-panel> </l:layout></j:jelly>floatingBox.jelly<j:jelly xmlns:j=&ldquo;jelly:core&rdquo; xmlns:st=&ldquo;jelly:stapler&rdquo; xmlns:d=&ldquo;jelly:define&rdquo; xmlns:l="/lib/layout" xmlns:t="/lib/hudson" xmlns:f="/lib/form" xmlns:i=&ldquo;jelly:fmt&rdquo; xmlns:local=&ldquo;local&rdquo;> <j:if test="${it.graphActive}"> ${from.graphName} <st:include page=&ldquo;normalGraph.jelly&rdquo;/> enlarge </j:if></j:jelly>The project page automatically includes the floating box, so we don;t require the summary hackenlargedGraph.jelly<j:jelly xmlns:j=&ldquo;jelly:core&rdquo; xmlns:st=&ldquo;jelly:stapler&rdquo; xmlns:d=&ldquo;jelly:define&rdquo; xmlns:l="/lib/layout" xmlns:t="/lib/hudson" xmlns:f="/lib/form"> <l:layout xmlns:plugin="/hudson/plugins/javancss/tags" css="/plugin/javancss/css/style.css"> <st:include it="${it.project}" page=&ldquo;sidepanel.jelly&rdquo;/> <l:main-panel> <j:if test="${it.graphActive}"> ${it.graphName} <st:include page=&ldquo;largeGraph.jelly&rdquo;/> </j:if> </l:main-panel> </l:layout></j:jelly>SummaryThat&rsquo;s it for part 5, next time we will implement the javancss parser and get the results for a build. Part 7 will finish off the plugin with the reports based on these two base classes.
'><meta property="og:url" content="https://stephenc.github.io/post/2008-02-01-writing-a-hudson-plug-in-part-5-reporting/"><meta property="og:site_name" content="Writing a Hudson plug-in (Part 5 – Reporting)"><meta property="og:image" content="https://stephenc.github.io/"><meta property="og:image:width" content="2048"><meta property="og:image:height" content="1024"><meta property="article:published_time" content="2008-02-01 00:00:00 +0000 UTC"></head><body><div style=position:relative><header class="Header js-details-container Details px-3 px-md-4 px-lg-5 flex-wrap flex-md-nowrap open Details--on"><div class="Header-item mobile-none" style=margin-top:-4px;margin-bottom:-4px><a class=Header-link href=https://stephenc.github.io/><img class=octicon height=32 width=32 src=/images/top-icon.png></a></div><div class="Header-item d-md-none"><button class="Header-link btn-link js-details-target" type=button onclick='document.querySelector("#header-search").style.display=document.querySelector("#header-search").style.display=="none"?"block":"none"'>
<svg height="24" class="octicon octicon-three-bars" viewBox="0 0 16 16" width="24"><path fill-rule="evenodd" d="M1 2.75A.75.75.0 011.75 2h12.5a.75.75.0 110 1.5H1.75A.75.75.0 011 2.75zm0 5A.75.75.0 011.75 7h12.5a.75.75.0 110 1.5H1.75A.75.75.0 011 7.75zM1.75 12a.75.75.0 100 1.5h12.5a.75.75.0 100-1.5H1.75z"/></svg></button></div><div style=display:none id=header-search class="Header-item Header-item--full flex-column flex-md-row width-full flex-order-2 flex-md-order-none mr-0 mr-md-3 mt-3 mt-md-0 Details-content--hidden-not-important d-md-flex"><div class="Header-search header-search flex-auto js-site-search position-relative flex-self-stretch flex-md-self-auto mb-3 mb-md-0 mr-0 mr-md-3 scoped-search site-scoped-search js-jump-to"><div class=position-relative><form target=_blank id=search-form accept-charset=UTF-8 method=get autocomplete=off><label class="Header-search-label form-control input-sm header-search-wrapper p-0 js-chromeless-input-container header-search-wrapper-jump-to position-relative d-flex flex-justify-between flex-items-center"><input type=text class="Header-search-input form-control input-sm header-search-input jump-to-field js-jump-to-field js-site-search-focus js-site-search-field is-clearable" name=q placeholder=Search autocomplete=off></label></form></div></div></div><div class="Header-item Header-item--full flex-justify-center d-md-none position-relative"><a class=Header-link href=https://stephenc.github.io/><img class="octicon octicon-mark-github v-align-middle" height=32 width=32 src=/images/top-icon.png></a></div><div class=Header-item style=margin-right:0><a href=javascript:void(0) class="Header-link no-select" onclick=switchTheme()><svg style="fill:var(--color-profile-color-modes-toggle-moon)" class="no-select" viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" clip-rule="evenodd" d="M4.52208 7.71754c3.05612.0 5.53362-2.47748 5.53362-5.5336C10.0557 1.93498 10.0392 1.68986 10.0074 1.44961 9.95801 1.07727 10.3495.771159 10.6474.99992c1.4679 1.12724 2.4141 2.90007 2.4141 4.89391.0 3.40575-2.7609 6.16667-6.16665 6.16667-2.94151.0-5.40199-2.0595-6.018122-4.81523C.794841 6.87902 1.23668 6.65289 1.55321 6.85451 2.41106 7.40095 3.4296 7.71754 4.52208 7.71754z"/></svg></a></div></header></div><div id=search-result class="container-lg px-3 new-discussion-timeline" style=display:none></div><div class=application-main><div><main><div class="gisthead pagehead bg-gray-light pb-0 pt-3 mb-4"><div class=px-0><div class="mb-3 d-flex px-3 px-md-3 px-lg-5"><div class="flex-auto min-width-0 width-fit mr-3"><div class=d-flex><div class="d-none d-md-block"><a class="avatar mr-2 flex-shrink-0" href=https://stephenc.github.io/><img class=avatar-user src=/images/avatar.jpg width=32 height=32></a></div><div class="d-flex flex-column"><h1 class="break-word f3 text-normal mb-md-0 mb-1"><span class=author><a href=https://stephenc.github.io/>Stephen Connolly</a>
</span><span class=path-divider>/</span>
<strong class="css-truncate css-truncate-target mr-1" style=max-width:410px><a href=https://stephenc.github.io/post/2008-02-01-writing-a-hudson-plug-in-part-5-reporting/>Writing a Hudson plug-in (Part 5 – Reporting)</a></strong></h1><div class="note m-0">Created <relative-time datetime="Fri, 01 Feb 2008 00:00:00 +0000" class=no-wrap>Fri, 01 Feb 2008 00:00:00 +0000</relative-time>
<span class=file-info-divider></span>
Modified <relative-time datetime="Fri, 01 Feb 2008 00:00:00 +0000" class=no-wrap>Fri, 01 Feb 2008 00:00:00 +0000</relative-time></div></div></div></div></div></div></div><div class="container-lg px-3 new-discussion-timeline"><div class="repository-content gist-content"><div><div class="js-gist-file-update-container js-task-list-container file-box"><div id=file-pytest class="file my-2"><div id=post-header class="file-header d-flex flex-md-items-center flex-items-start sticky-header" style=z-index:2><div class="file-info d-flex flex-md-items-center flex-items-start flex-order-1 flex-auto"><div class="text-mono f6 flex-auto pr-3 flex-order-2 flex-md-order-1 mt-2 mt-md-0"><summary id=toc-toggle onclick=clickToc() class="btn btn-octicon m-0 mr-2 p-2"><svg aria-hidden="true" viewBox="0 0 16 16" height="16" width="16" class="octicon octicon-list-unordered"><path fill-rule="evenodd" d="M2 4a1 1 0 100-2 1 1 0 000 2zm3.75-1.5a.75.75.0 000 1.5h8.5a.75.75.0 000-1.5h-8.5zm0 5a.75.75.0 000 1.5h8.5a.75.75.0 000-1.5h-8.5zm0 5a.75.75.0 000 1.5h8.5a.75.75.0 000-1.5h-8.5zM3 8A1 1 0 111 8a1 1 0 012 0zm-1 6a1 1 0 100-2 1 1 0 000 2z"/></svg></summary><details-menu class=SelectMenu id=toc-details style="display: none;"><div class="SelectMenu-modal rounded-3 mt-1" style=max-height:340px><div class="SelectMenu-list SelectMenu-list--borderless p-2" style=overscroll-behavior:contain id=toc-list></div></div></details-menu>1211 Words</div><div class="file-actions flex-order-2 pt-0"><a class="muted-link mr-3" href=/tags/jenkins><svg class="octicon octicon-tag" viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M2.5 7.775V2.75a.25.25.0 01.25-.25h5.025a.25.25.0 01.177.073l6.25 6.25a.25.25.0 010 .354l-5.025 5.025a.25.25.0 01-.354.0l-6.25-6.25A.25.25.0 012.5 7.775zm-1.5.0V2.75C1 1.784 1.784 1 2.75 1h5.025c.464.0.91.184 1.238.513l6.25 6.25a1.75 1.75.0 010 2.474l-5.026 5.026a1.75 1.75.0 01-2.474.0l-6.25-6.25A1.75 1.75.0 011 7.775zM6 5a1 1 0 100 2 1 1 0 000-2z"/></svg>
Jenkins</a></div></div></div><div class="Box-body px-5 pb-5" style=z-index:1><article class="markdown-body entry-content container-lg"><p>Until now we have been generating classes that collect the results we want to display. We have not hooked into Hudson&rsquo;s methods of displaying reports. There are essentially four places that we could want to generate reports:In each individual build (we&rsquo;ll call this a Single Build Report),In the project (we&rsquo;ll call this a Single Project Report),In the summary of all the Maven 2 module builds associated with a multi-module Maven 2 build (we&rsquo;ll call this an Aggregate Build Report), and finallyIn the Maven 2 project itself (we&rsquo;ll call this an Aggregate Project Report).To make matters more confusing, each of these reports usually to implement different classes and need to implement different interfaces:Project Reports usually inherit from ActionableBuild Reports usually inherit from HealthReportingActionSingle Build Reports in Maven 2 projects need to implement AggregatableActionWhat we need is to put some common framework around these reports to ensure that we are not repeating ourselves all the time. In general, each of these four reports will be doing mostly the same things.The Build Reports will be displaying the results for a specific buildThe Project Reports will be displaying the results for the latest build (and possibly a trend chart if that makes sense)The Aggregate Reports will be displaying the aggregate of all the Single ReportsSound&rsquo;s like a job for multiple inheritance! Fortune would have it that Java does not support multiple inheritance, so we will have to use some form of composition to get the same effect, and generics can help reduce the repetition too. But enough! On to the solution.AbstractBuildActionWe&rsquo;ll start with a parent class for all our Build Reports. We&rsquo;ll make this class generic, parameterised by the Build class that it operates on, so that we can use the same core code for all the Build Reports:package hudson.plugins.helpers;import hudson.model.AbstractBuild;import hudson.model.HealthReportingAction;public abstract class AbstractBuildAction&lt;BUILD extends AbstractBuild> implements HealthReportingAction { private BUILD build = null; protected AbstractBuildAction() { } public synchronized BUILD getBuild() { return build; } public synchronized void setBuild(BUILD build) { if (this.build == null && this.build != build) { this.build = build; } }}We store a reference to the build in a local variable and provide a getter for the build. Ideally we would like to the build variable to be final and initialize it in the constructor. However, Hudson&rsquo;s remoting interface will get in the way of this for any actions created on the slave. The solution is to use a setter to set the build. Additionally, we have some logic that makes this setter write-once. This is just a safety net to stop us from accidentally confusing Hudson. Strictly speaking, if you are careful the setter can be justa a simple setter and not write once.[Correction] We also need to modify BuildProxy so that it calls our setter for us for actions added from slave side executions:package hudson.plugsin.helpers;&mldr;public final class BuildProxy implements Serializable { &mldr; private final List&lt;AbstractBuildAction&lt;AbstractBuild&#187; actions = new ArrayList&lt;AbstractBuildAction&#187;(); &mldr; public void updateBuild(AbstractBuild&lt;,?> build) { for (AbstractBuildAction&lt;AbstractBuild> action: actions) { if (!build.getActions().contains(action)) { action.setBuild(build); build.getActions().add(action); } } if (result != null && result.isWorseThan(build.getResult())) { build.setResult(result); } } &mldr; public List&lt;AbstractBuildAction&lt;AbstractBuild&#187; getActions() { return actions; } &mldr;}[/Correction]In addition to these simple getters and setters, we want to provide a framework for displaying the report detail. Each different type of report has different ways of fitting into the Hudson UI. We are going to attempt to standardise these by using wrapper .jelly files to call a standard set which implementing classes can override. Jelly files are stored as resources in the hudson plugin, so with the Maven2 project structure for a Hudson plugin, the java source is /src/main/java/hudson/plugins/helpers/AbstractBuildAction.java and the jelly files for this java class are in /src/main/resources/hudson/plugins/helpers/AbstractBuildAction/. The basic things that all build reports want to do are as follows:A main report detail page (e.g. package level summary of the number of lines of code)A graph of some sort, with the option to enlarge it. (e.g. trend graph of the number of lines of code)A simple summary of the report for the main page (i.e. &ldquo;17,345 lines of code (+1,534)")We will implement this functionality with some properties of the AbstractBuildAction, and some default .jelly files. First the additional properties:&mldr;public abstract class AbstractBuildAction&lt;BUILD extends AbstractBuild> implements HealthReportingAction { &mldr; public boolean isFloatingBoxActive() { return false; } public boolean isGraphActive() { return false; } public String getGraphName() { return getDisplayName(); } public String getSummary() { return &ldquo;&rdquo;; }}These four properties will be used to control how the action appears. isFloatingBoxActive allows us to enable the floating box on the build summary page. isGraphActive allows us to activate the graph inside the floating box. getGraphName should return the title that will be displayed above the graph. And finally, getSummary will control the summary text to display beside the build report icon on the build summary page.Next we have some empty default place-holder jelly files. These will be the jelly files that we can override in our actual reports:reportDetail.jelly&lt;j:jelly xmlns:j=&ldquo;jelly:core&rdquo; xmlns:st=&ldquo;jelly:stapler&rdquo; xmlns:d=&ldquo;jelly:define&rdquo; xmlns:l="/lib/layout&rdquo; xmlns:t="/lib/hudson" xmlns:f="/lib/form">&lt;/j:jelly>normalGraph.jelly&lt;j:jelly xmlns:j=&ldquo;jelly:core&rdquo; xmlns:st=&ldquo;jelly:stapler&rdquo; xmlns:d=&ldquo;jelly:define&rdquo; xmlns:l="/lib/layout" xmlns:t="/lib/hudson" xmlns:f="/lib/form">&lt;/j:jelly>largeGraph.jelly&lt;j:jelly xmlns:j=&ldquo;jelly:core&rdquo; xmlns:st=&ldquo;jelly:stapler&rdquo; xmlns:d=&ldquo;jelly:define&rdquo; xmlns:l="/lib/layout" xmlns:t="/lib/hudson" xmlns:f="/lib/form">&lt;/j:jelly>The reportDetail.jelly page will be used for the main report detail page, the normalGraph.jelly page will be used for the floating trend graph, while the largeGraph.jelly page will be used for the enlarged graph. To hook these pages into the Hudson framework, we need the following jelly pages:index.jelly&lt;j:jelly xmlns:j=&ldquo;jelly:core&rdquo; xmlns:st=&ldquo;jelly:stapler&rdquo; xmlns:d=&ldquo;jelly:define&rdquo; xmlns:l="/lib/layout" xmlns:t="/lib/hudson" xmlns:f="/lib/form"> &lt;l:layout xmlns:plugin="/hudson/plugins/javancss/tags" css="/plugin/javancss/css/style.css"> &lt;st:include it="${it.build}" page=&ldquo;sidepanel.jelly&rdquo;/> &lt;l:main-panel> ${it.displayName} &lt;j:if test="${it.graphActive}"> ${it.graphName} &lt;st:include page=&ldquo;normalGraph.jelly&rdquo;/> &lt;/j:if> &lt;st:include page=&ldquo;reportDetail.jelly&rdquo;/> &lt;/l:main-panel> &lt;/l:layout>&lt;/j:jelly>This page will also include the trend graph if it is activefloatingBox.jelly&lt;j:jelly xmlns:j=&ldquo;jelly:core&rdquo; xmlns:st=&ldquo;jelly:stapler&rdquo; xmlns:d=&ldquo;jelly:define&rdquo; xmlns:l="/lib/layout" xmlns:t="/lib/hudson" xmlns:f="/lib/form"> &lt;j:if test="${it.graphActive}"> ${from.graphName} &lt;st:include page=&ldquo;normalGraph.jelly&rdquo;/> enlarge &lt;/j:if>&lt;/j:jelly>summary.jelly&lt;j:jelly xmlns:j=&ldquo;jelly:core&rdquo; xmlns:st=&ldquo;jelly:stapler&rdquo; xmlns:d=&ldquo;jelly:define&rdquo; xmlns:l="/lib/layout" xmlns:t="/lib/hudson" xmlns:f="/lib/form" xmlns:i=&ldquo;jelly:fmt&rdquo;> &lt;t:summary icon="${it.iconFileName}"> ${it.displayName} ${it.summary} &lt;/t:summary> &lt;j:if test="${it.floatingBoxVisible}}"> &lt;st:include page=&ldquo;floatingBox.jelly&rdquo;/> &lt;/j:if>&lt;/j:jelly>Note that the build main page does not support floating boxes, so we have to hack it in via the summary.jelly pageenlargedGraph.jelly&lt;j:jelly xmlns:j=&ldquo;jelly:core&rdquo; xmlns:st=&ldquo;jelly:stapler&rdquo; xmlns:d=&ldquo;jelly:define&rdquo; xmlns:l="/lib/layout" xmlns:t="/lib/hudson" xmlns:f="/lib/form"> &lt;l:layout xmlns:plugin="/hudson/plugins/javancss/tags" css="/plugin/javancss/css/style.css"> &lt;st:include it="${it.build}" page=&ldquo;sidepanel.jelly&rdquo;/> &lt;l:main-panel> &lt;j:if test="${it.graphActive}"> ${it.graphName} &lt;st:include page=&ldquo;largeGraph.jelly&rdquo;/> &lt;/j:if> &lt;/l:main-panel> &lt;/l:layout>&lt;/j:jelly>AbstractProjectActionThis is similar to AbstractBuildAction, however, we don&rsquo;t have to deal with the write-once setter problem.package hudson.plugins.helpers;import hudson.model.AbstractProject;import hudson.model.Actionable;abstract public class AbstractProjectAction&lt;PROJECT extends AbstractProject> extends Actionable { private final PROJECT project; protected AbstractProjectAction(PROJECT project) { this.project = project; } public PROJECT getProject() { return project; } public boolean isFloatingBoxActive() { return true; } public boolean isGraphActive() { return false; } public String getGraphName() { return getDisplayName(); }}Again we have a set of jelly files, we&rsquo;ll repeat the same placeholders:reportDetail.jelly&lt;j:jelly xmlns:j=&ldquo;jelly:core&rdquo; xmlns:st=&ldquo;jelly:stapler&rdquo; xmlns:d=&ldquo;jelly:define&rdquo; xmlns:l="/lib/layout" xmlns:t="/lib/hudson" xmlns:f="/lib/form">&lt;/j:jelly>normalGraph.jelly&lt;j:jelly xmlns:j=&ldquo;jelly:core&rdquo; xmlns:st=&ldquo;jelly:stapler&rdquo; xmlns:d=&ldquo;jelly:define&rdquo; xmlns:l="/lib/layout" xmlns:t="/lib/hudson" xmlns:f="/lib/form">&lt;/j:jelly>largeGraph.jelly&lt;j:jelly xmlns:j=&ldquo;jelly:core&rdquo; xmlns:st=&ldquo;jelly:stapler&rdquo; xmlns:d=&ldquo;jelly:define&rdquo; xmlns:l="/lib/layout" xmlns:t="/lib/hudson" xmlns:f="/lib/form">&lt;/j:jelly>The other link in pages are similar, only changing from a reference for ${it.build} to ${it.project}index.jelly&lt;j:jelly xmlns:j=&ldquo;jelly:core&rdquo; xmlns:st=&ldquo;jelly:stapler&rdquo; xmlns:d=&ldquo;jelly:define&rdquo; xmlns:l="/lib/layout" xmlns:t="/lib/hudson" xmlns:f="/lib/form"> &lt;l:layout xmlns:plugin="/hudson/plugins/javancss/tags" css="/plugin/javancss/css/style.css"> &lt;st:include it="${it.project}" page=&ldquo;sidepanel.jelly&rdquo;/> &lt;l:main-panel> ${it.displayName} &lt;j:if test="${it.graphActive}"> ${it.graphName} &lt;st:include page=&ldquo;normalGraph.jelly&rdquo;/> &lt;/j:if> &lt;st:include page=&ldquo;reportDetail.jelly&rdquo;/> &lt;/l:main-panel> &lt;/l:layout>&lt;/j:jelly>floatingBox.jelly&lt;j:jelly xmlns:j=&ldquo;jelly:core&rdquo; xmlns:st=&ldquo;jelly:stapler&rdquo; xmlns:d=&ldquo;jelly:define&rdquo; xmlns:l="/lib/layout" xmlns:t="/lib/hudson" xmlns:f="/lib/form" xmlns:i=&ldquo;jelly:fmt&rdquo; xmlns:local=&ldquo;local&rdquo;> &lt;j:if test="${it.graphActive}"> ${from.graphName} &lt;st:include page=&ldquo;normalGraph.jelly&rdquo;/> enlarge &lt;/j:if>&lt;/j:jelly>The project page automatically includes the floating box, so we don;t require the summary hackenlargedGraph.jelly&lt;j:jelly xmlns:j=&ldquo;jelly:core&rdquo; xmlns:st=&ldquo;jelly:stapler&rdquo; xmlns:d=&ldquo;jelly:define&rdquo; xmlns:l="/lib/layout" xmlns:t="/lib/hudson" xmlns:f="/lib/form"> &lt;l:layout xmlns:plugin="/hudson/plugins/javancss/tags" css="/plugin/javancss/css/style.css"> &lt;st:include it="${it.project}" page=&ldquo;sidepanel.jelly&rdquo;/> &lt;l:main-panel> &lt;j:if test="${it.graphActive}"> ${it.graphName} &lt;st:include page=&ldquo;largeGraph.jelly&rdquo;/> &lt;/j:if> &lt;/l:main-panel> &lt;/l:layout>&lt;/j:jelly>SummaryThat&rsquo;s it for part 5, next time we will implement the javancss parser and get the results for a build. Part 7 will finish off the plugin with the reports based on these two base classes.</p></article></div></div></div></div></div></div></main></div><script type=application/javascript src=https://stephenc.github.io/js/toc.js></script><link rel=stylesheet href=https://stephenc.github.io/css/toc.css></div><div class="footer container-xl width-full p-responsive"><div class="position-relative d-flex flex-row-reverse flex-lg-row flex-wrap flex-lg-nowrap flex-justify-center flex-lg-justify-between flex-sm-items-center pt-6 pb-2 mt-6 f6 text-gray border-top border-gray-light"><a aria-label=Homepage title=GitHub class="footer-octicon d-none d-lg-block mr-lg-4" href=https://stephenc.github.io/><svg height="24" class="octicon octicon-mark-github" viewBox="0 0 16 16" width="24"><path fill-rule="evenodd" d="M8 0C3.58.0.0 3.58.0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38.0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95.0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12.0.0.67-.21 2.2.82.64-.18 1.32-.27 2-.27s1.36.09 2 .27c1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15.0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48.0 1.07-.01 1.93-.01 2.2.0.21.15.46.55.38A8.013 8.013.0 0016 8c0-4.42-3.58-8-8-8z"/></svg></a><ul class="list-style-none d-flex flex-wrap col-12 flex-justify-center flex-lg-justify-between mb-2 mb-lg-0"><li class="mr-3 mr-lg-0">Theme by <a href=https://github.com/MeiK2333/github-style>github-style</a></li><li class="mr-3 mr-lg-0">GitHub and the Invertocat logo are trademarks of <a href=https://github.com/>GitHub, Inc.</a></li></ul></div><div class="d-flex flex-justify-center pb-6"><span class="f6 text-gray-light"></span></div></div></body><script type=application/javascript src=https://stephenc.github.io/js/github-style.js></script><script src=https://cdn.jsdelivr.net/npm/fuse.js/dist/fuse.min.js></script><script type=application/javascript src=https://stephenc.github.io/js/search.js></script></html>